#!/bin/sh
# Wrapper around clang-format to make enforcing new oblong coding style easy

# Abort on error
set -e

# Avoid bashisms
POSIXLY_CORRECT=1

# Running operating system
OS=$(uname -s)

abort() {
  echo "error: $*"
  exit 1
}

print_help_menu() {
  cat <<_EOF_
Spruce: Don't Let Messes Overstay Their Welcome
Handy-dandy oblong-specific C++ code beautifier
See https://gitlab.oblong.com/platform/docs/wikis/coding-style/

usage: spruce [-o outdir] file...         (reformat given files)
or:    spruce [-o outdir] all             (reformat all files)
or:    spruce changes                     (reformat all edits, staged and unstaged)
or:    spruce check [files...]            (list files that need reformatting)
or:    spruce precommit                   (abort if a staged file needs reformatting)
or:    spruce freebase <sha1_before_reformat> <sha1_after_reformat> <upstream_branch>
or:    spruce plugin (emacs|vim|sublime)  (custom plugin support)
or:    spruce style                       (output our .clang-format to stdout)

'freebase' is for fixing a branch that is stale because upstream was spruced up
after the branch was created.

'plugin' has options for emacs, vim or sublime:
    'sublime': produces a file, 'clang_format_custom.sublime-settings' which
               should be used with the plugin: https://packagecontrol.io/packages/Clang%20Format
_EOF_
  if $IN_ERR
  then
    exit 1
  fi
  exit 0
}

# Expected version of clang-format
# note: Must match debian/control
#CLANG_FORMAT_VERSION_DESC="(tags/google/stable/2016-12-09)"
#CLANG_FORMAT_SHORT_VERSION="4.0.0"
#CLANG_FORMAT_BREW_PKG="clang-format"
CLANG_FORMAT_VERSION_DESC="(tags/RELEASE_380/final)"
CLANG_FORMAT_SHORT_VERSION="3.8"
CLANG_FORMAT_BREW_PKG="clang-format38"

# Name of clang-format as a binary
CLANG_FORMAT_PROGNAME="clang-format"
CLANG_FORMAT_PKGNAME="clang-format"
GIT_CLANG_FORMAT_PROGNAME="git-clang-format"

if [ "$OS" = "Linux" ] ; then
  GIT_CLANG_FORMAT_PROGNAME="$GIT_CLANG_FORMAT_PROGNAME-$CLANG_FORMAT_SHORT_VERSION"
  CLANG_FORMAT_PROGNAME="$CLANG_FORMAT_PROGNAME-$CLANG_FORMAT_SHORT_VERSION"
  CLANG_FORMAT_PKGNAME="$CLANG_FORMAT_PROGNAME"
elif [ "$OS" = "Darwin" ] ; then
  CLANG_FORMAT_PKGNAME="$CLANG_FORMAT_BREW_PKG"
fi

# Yovo paths to ignore when formatting
IGNORE_PATHS=' |gtest'
IGNORE_PATHS="$IGNORE_PATHS|valgrind"
IGNORE_PATHS="$IGNORE_PATHS|ob-hash.c|ob-hash-city.c|ob-hash-win32.c"
IGNORE_PATHS="$IGNORE_PATHS|ob-mvtypes.c"
IGNORE_PATHS="$IGNORE_PATHS|dSFMT.c|dSFMT.h"
IGNORE_PATHS="$IGNORE_PATHS|test-hash.c"
IGNORE_PATHS="$IGNORE_PATHS|benchmarks/city"
IGNORE_PATHS="$IGNORE_PATHS|openssl_hostname_validations"

# Helpers to take our format string where it needs to go

# Pick a place for the file, and remove it when we exit
CLANG_FORMAT_STYLE_FILE=/tmp/spruce.clang-format.$$
cleanup_style() {
    rm -f "$CLANG_FORMAT_STYLE_FILE"
}
trap cleanup_style 0

# Get style suitable for users to put in ~/.clang-format if they wish
cat_style_file() {
   cat $CLANG_FORMAT_STYLE_FILE
}

# Get style suitable for -style=, but less legible
cat_style_string() {
   tr '\012' ',' < $CLANG_FORMAT_STYLE_FILE | sed 's/^/{/;s/,$/}/'
}

# Our format is embedded in this script in alphabetical order.
# We turn this into a single line by joining with commas, so
#  - maps are a bit funny
#  - we can't use comments inside this style, so put 'em here

#--- style comments follow ---
# AlwaysBreakBeforeMultilineStrings: false # true forces line breaks after OB_FMT_64
# BraceWrapping:
#  AfterEnum: 'true'                       # Broken: https://bugs.llvm.org/show_bug.cgi?id=27381
#--- end of style comments ---
# And finally, our style:
cat > "$CLANG_FORMAT_STYLE_FILE" <<_EOF_
Language: Cpp
AccessModifierOffset: -1
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: false
AlignConsecutiveDeclarations: false
AlignEscapedNewlinesLeft: false
AlignOperands: true
AlignTrailingComments: true
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: true
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: Inline
AllowShortIfStatementsOnASingleLine: false
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: true
BinPackArguments: true
BinPackParameters: true
BraceWrapping: {AfterClass: true
  AfterControlStatement: true
  AfterEnum: true
  AfterFunction: true
  AfterNamespace: false
  AfterObjCDeclaration: true
  AfterStruct: true
  AfterUnion: true
  BeforeCatch: true
  BeforeElse: true
  IndentBraces: true}
BreakBeforeBinaryOperators: All
BreakBeforeBraces: Custom
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
ColumnLimit: 80
CommentPragmas: ''
ConstructorInitializerAllOnOneLineOrOnePerLine: true
ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 2
Cpp11BracedListStyle: true
DerivePointerAlignment: false
DisableFormat: false
ExperimentalAutoDetectBinPacking: false
ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]
IndentCaseLabels: true
IndentWidth: 2
IndentWrappedFunctionNames: false
KeepEmptyLinesAtTheStartOfBlocks: true
MacroBlockBegin: ''
MacroBlockEnd:   ''
MaxEmptyLinesToKeep: 3
NamespaceIndentation: None
PointerAlignment: Right
ReflowComments: false
SortIncludes: false
SpaceAfterCStyleCast: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeParens: Always
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 2
SpacesInAngles: false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard: Cpp11
TabWidth: 2
UseTab: Never
_EOF_


OUTPUT_PATH=""
IN_ERR=false

case "$1" in
""|-h|--help)
    print_help_menu
    ;;
-o)
    shift
    OUTPUT_PATH=$1
    shift
    ;;
-*)
    echo "Invalid option: $1" >&2
    IN_ERR=true
    print_help_menu
    ;;
esac

update_brew() {
  b=$(which brew)
  if [ "$b" = "" ] ; then
    msg="ERROR: brew: command not found. Shall I install it for you (y/n)?"
    printf %s "$msg "
    read ans
    INVALID=true
    while $INVALID ; do
      case "$ans" in
        y|Y|yes)
          INVALID=false
          ;;
        n|N|no)
          abort "Failed to run clang-format"
          ;;
        * )
          echo  "Invalid Answer. Please answer [y/n]: "
          read ans
          ;;
      esac
    done

    echo "Installing brew..."
    brew_url="https://raw.githubusercontent.com/Homebrew/install/master/install"
    /usr/bin/ruby -e "$(curl -fsSL $brew_url)"

    b=$(which brew)
    if [ "$b" = " " ] ; then
      abort "Failed to install brew"
    fi
  fi

  echo "Updating brew..."
  brew update
}

unlink_clang_format() {
  if [ "$OS" = "Darwin" ] ; then
    for p in $(brew list | grep clang-format)
    do
      brew unlink "$p"
    done
  fi
}

install_clang_format() {
  echo "installing clang-format..."
  if [ "$OS" = "Darwin" ] ; then
    brew tap Homebrew/homebrew-versions
    brew install $CLANG_FORMAT_PKGNAME
    brew link --force $CLANG_FORMAT_PKGNAME
  elif [ "$OS" = "Linux" ] ; then
    sudo apt-get install $CLANG_FORMAT_PKGNAME
  fi
}

test_clang_format_version() {
  clang_v=$($CLANG_FORMAT_PROGNAME --version || true)
  case "$clang_v" in
  *"$CLANG_FORMAT_VERSION_DESC"*) return;;
  esac

  if [ "$clang_v" = "" ] ; then
    msg="ERROR: clang-format: command not found. Shall I install it for you (y/n)?"
  else
    echo "ERROR: clang-format: wrong version ($clang_v)"
    msg="Shall I install $CLANG_FORMAT_SHORT_VERSION for you (y/n)?"
    if [ "$OS" = "Darwin" ] ; then
      msg="$msg (WARNING: Answering yes will unlink your current version)"
    fi
  fi

  printf %s "$msg "
  read ans
  INVALID=true
  while $INVALID ; do
    case "$ans" in
      y|Y|yes)
        INVALID=false
        ;;
      n|N|no)
        abort "Failed to run clang-format"
        ;;
      * )
        printf %s "Invalid Answer. Please answer [y/n]: "
        read ans
        ;;
    esac
  done

  if [ "$OS" = "Darwin" ] ; then
    update_brew
    if [ "$clang_v" != "" ] ; then
      unlink_clang_format
    fi
  elif [ "$OS" = "Linux" ] ; then
    sudo apt-get update
  fi

  install_clang_format
  clang_v=$($CLANG_FORMAT_PROGNAME --version)

  case "$clang_v" in
  *"$CLANG_FORMAT_VERSION_DESC"*)
    echo "Using Clang Version: $clang_v"
    ;;
  *)
    abort "Wanted clang-format version $CLANG_FORMAT_VERSION_DESC, got $clang_v.  Aborting."
    ;;
  esac
}

# Logic borrowed from mongodb:
# https://github.com/mongodb/mongo/blob/master/buildscripts/clang_format.py#L727
reformat_branch() {
  echo "reformat a branch made before a clang-format run..."

  pre=$1
  post=$2
  master=$3

  val="$(git rev-parse --show-toplevel)"
  if [ "$(pwd)" != "$val" ] ; then
    abort "ERROR: Branch reformatting must be done from the repo root: $val"
  fi

  # if not os.path.exists("buildscripts/clang_format.py"):
  #     raise ValueError("reformat-branch is only supported in the mongo repo")

  # Validate that user passes valid commits
  git cat-file -e "$pre" > /dev/null 2>&1
  if [ $? != 0 ] ; then
    abort "ERROR: Commit prior to reformat $pre is not a valid commit in this repo"
  fi
  git cat-file -e "$post" > /dev/null 2>&1
  if [ $? != 0 ] ; then
    abort "ERROR: Commit after reformat $post is not a valid commit in this repo\n"
  fi

  git merge-base --is-ancestor "$pre" "$post" > /dev/null 2>&1
  if [ $? != 0 ] ; then
    abort "ERROR: Commit Prior to Reformat $pre is not a valid ancestor of Commit After Reformat $post in this repo"
  fi

  # Validate the user is on a local branch that has the right merge base
  git symbolic-ref --quiet HEAD > /dev/null 2>&1
  if [ $? = 1 ] ; then
    abort "ERROR: You must not run this script in a detached HEAD state"
  fi

  # Validate the user has no pending changes
  if ! git diff --quiet
  then
    abort "ERROR: Your working tree has pending changes. You must have a clean working tree before proceeding."
  fi

  val=$(git merge-base HEAD "$pre") > /dev/null 2>&1
  if [ "$val" != "$pre" ] ; then
    abort "ERROR: Please rebase to $pre and resolve all conflicts before running this script"
  fi

  val=$(git merge-base HEAD "$master") > /dev/null 2>&1
  if [ "$val" != "$pre" ] ; then
    abort "ERROR: This branch appears to already have advanced too far through the merge process"
  fi

  # Everything looks good so lets start going through all the commits
  val=$(git rev-parse --abbrev-ref HEAD) > /dev/null 2>&1
  if [ "$val" = "HEAD" ] ; then
    abort "Branch is currently detached"
  fi
  new_branch="$val-reformatted"

  if git rev-parse --verify "$new_branch" > /dev/null 2>&1
  then
    abort "The branch $new_branch already exists. Please delete or rename the current branch."
  fi

  commits=$(git log --reverse --pretty=format:%H "$pre"..HEAD) > /dev/null 2>&1

  previous_commit_base=$post

  # # Go through all the commits the user made on the local branch and migrate to a new branch
  # # that is based on post_reformat commits instead
  for c in $commits
  do
    echo "${c}:"
    git checkout --quiet "$c" > /dev/null 2>&1

    deleted_files=""
    # Format each of the files by checking out just a single commit from the user's branch
    commit_files=$(git diff --name-only HEAD~) > /dev/null 2>&1
    for commit_file in $commit_files
    do
      # Format each file needed if it was not deleted
      if [ ! -e "$commit_file" ] ; then
        echo "Skipping file $commit_file since it has been deleted in commit '$c'"
        deleted_files="${deleted_files}$commit_file:"
        continue
      fi

      if ! is_formattable_file "$commit_file" ; then
        echo "Skipping file $commit_file since it is not a file clang_format should format"
      else
        $CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -i "$commit_file"
        echo "format $commit_file"
      fi
    done

    # Check if anything needed reformatting, and if so amend the commit
    if git diff --quiet > /dev/null 2>&1
    then
      echo "Commit $c needed no reformatting"
    else
      git commit --all --amend --no-edit > /dev/null 2>&1
    fi

    # Rebase our new commit on top the post-reformat commit
    prev_commit=$(git rev-parse HEAD) > /dev/null 2>&1

    # Checkout the new branch with the reformatted commits
    # Note: we will not name as a branch until we are done with all commits on the local branch
    git checkout --quiet "$previous_commit_base" > /dev/null 2>&1

    # Copy each file from the reformatted commit on top of the post reformat
    for diff_file in $(git diff --name-only "$prev_commit"~.."$prev_commit")
    do
      # If the file was deleted in the commit we are reformatting, we need to delete it again
      case "$deleted_files" in
      *"$diff_file"*)::
        git rm "$diff_file" > /dev/null 2>&1
        continue
        ;;
      esac

      # The file has been added or modified, continue as normal
      root_dir=$(dirname "$diff_file")
      if [ ! -e "$root_dir" ] ; then
        mkdir -p "$root_dir"
      fi
      git show "$prev_commit":"$diff_file" > "$diff_file"

      git add "$diff_file" > /dev/null 2>&1
    done

    # Create a new commit onto clang-formatted branch
    git commit --reuse-message="$prev_commit" > /dev/null 2>&1

    previous_commit_base=$(git rev-parse HEAD)
  done

  # Create a new branch to mark the hashes we have been using
  git checkout -b "$new_branch" > /dev/null 2>&1

  cat <<_EOF_
-----------------------------------------
NOTICE:
reformat-branch is done running.
A copy of your branch has been made named $new_branch, and formatted with clang-format.
The original branch has been left unchanged.
The next step is to rebase the new branch on 'iz'.
_EOF_
}

test_clang_format_version

preprocess_stdin() {
  # Work around https://llvm.org/bugs/show_bug.cgi?id=30849
  # This cleans up the case where there's an OB_P* followed by
  # new lines or comments, which clang-format has no idea what to
  # do with. So we insert a unique spruce varaible before the
  # new line or comment for the post-processing to remove later.
  # This seems like a better option than practically writing our
  # own c++ compiler to figure out when clang-format screwed up.
  perl -e 'while (<STDIN>) {
            if ($prefice && ((/^$/) || (/( *)\/[\/\*]/))) {
              print "int32 SPRUCE_IT\;$_";
              next;
            };
            if ($prefice) { $prefice=0; };
            if (/OB_P(RIVATE|ROTECTED|UBLIC):/) { $prefice=1; };
            print;
          }'
  #
}

postprocess_stdin() {
  # Work around https://llvm.org/bugs/show_bug.cgi?id=30849
  # and guard inserting multiple newlines afer muliple runs
  # Use perl instead of sed because it supports multiline search
  # and is present by default on linux and mac.
  # This does the following:
  #   1-3: for OB_P* with trailing information, delete the space
  #        before the colon, remove one space before the OB_P*, and
  #        put the trailing information on the next line, indented
  #        accordingly
  #   4-6: Same as 1-3 but for the case where there isn't anything
  #        trailing on the line.
  #   5-6: Find lines containing our pre-processed spruce string
  #        and delete the string, leaving just a new line or comment
  perl -0777 -p \
    -e 's/( *)(  OB_PRIVATE :)(.+\n)/$1 OB_PRIVATE:\n$1 $3/g;' \
    -e 's/( *)(  OB_PROTECTED :)(.+\n)/$1 OB_PROTECTED:\n$1 $3/g;' \
    -e 's/( *)(  OB_PUBLIC :)(.+\n)/$1 OB_PUBLIC:\n$1 $3/g;' \
    -e 's/( *)(  OB_PRIVATE :\n)/$1 OB_PRIVATE:\n/g;' \
    -e 's/( *)(  OB_PROTECTED :\n)/$1 OB_PROTECTED:\n/g;' \
    -e 's/( *)(  OB_PUBLIC :\n)/$1 OB_PUBLIC:\n/g;' \
  | perl -p \
    -e 's/( *)(int32 SPRUCE_IT\;\n)/\n/g;' \
    -e 's/( *)(int32 SPRUCE_IT\;)( *)(.+)/$1$4/g;' \
  #
}

# Return true if the argument looks like the name of a C/C++/objC file.
# (Note: this is one of several filtering methods in this script.
# format_changes, precommit, and check without args use their own ways of
# selecting files.  This one is used if user specifies
# filenames directly on commandline; it accepts more types than
# format_changes and precommit do.)
is_formattable_file() {
    case "$1" in
    *.[cChHm])            ;; # .c .C .h .H .m
    *.[cChH][+pPx][+pPx]) ;; # .cpp .CPP .c++ .cxx .hpp .HPP etc.
    *.mm)                 ;; # objective-C++
    *)
        return 1             # false
        ;;
    esac
    return 0                 # true
}

format_files() {
  for f
  do
    echo "$f"
    if ! is_formattable_file "$f"
    then
        echo "Skipping $f (filename doesn't look like c/c++/objc)"
        continue
    fi
    outf="$f"
    if [ "$OUTPUT_PATH" = "" ] ; then
      preprocess_stdin < "$outf" > spruce-tmp.tmp && mv spruce-tmp.tmp "$outf"
      $CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -i "$f"
    else
      dname=$(dirname "$f")
      mkdir -p "$OUTPUT_PATH/$dname"
      outf="$OUTPUT_PATH/$f"
      preprocess_stdin < "$f" > spruce-tmp.tmp && mv spruce-tmp.tmp "$outf"
      $CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -i "$outf"
    fi
    postprocess_stdin < "$outf" > spruce-tmp.tmp && mv spruce-tmp.tmp "$outf"
  done
}

# Format all staged .C/.c/.h/.cpp files, even if they're in the IGNORE_PATHS
# FIXME: stop using git-clang-format so we can skip files in IGNORE_PATHS
format_changes() {
#  $GIT_CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -f --extensions c,cpp,h
  for outf in $(git status | awk '/modified:/ {print $2}' | egrep -wv "$IGNORE_PATHS" )
  do
    echo "$outf"
    if ! is_formattable_file "$outf"
    then
        echo "Skipping $outf (filename doesn't look like c/c++/objc)"
        continue
    fi
    preprocess_stdin < "$outf" > spruce-tmp.tmp && mv spruce-tmp.tmp "$outf"
    $CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -i "$outf"
    postprocess_stdin < "$outf" > spruce-tmp.tmp && mv spruce-tmp.tmp "$outf"
  done
}

sublime_wants_containers_on_single_line() {
  perl -e 'while (<STDIN>) {
            if (/:( +)"[[{]/) { $merge=1; };
            if ($merge) {
              s/"(\w+)"/'\''$1'\''/g;
              s/\n$//;
              if (/[]}]/) { $merge=0;  s/$/\n/; };
            };
            print;
          }'
}

reformat_sublime() {
  echo "{"

  # in the order of the lines below:
  #   1. Put all keys/vals (words) in double quotes (i.e k: v -> "k": "v")
  #   2. Put quotes around array blocks (i.e. [] -> "[]")
  #   3. Add a comma at the end of every line
  #   4/5. Put quotes around map blocks (i.e. {} -> "{}")
  #   6. For every array/map block, remove new lines and replace double quotes with singles
  #   7/8. Path fallout from #6 which changes the initial key to single quotes (bad)
  #   9. Skip empty strings
  perl -p \
    -e 's/(([A-Za-z]+[0-9_-]*)+)/"$1"/g;' \
    -e 's/(\[.*])/"$1"/g;' \
    -e 's/\n/,\n/g;' \
    -e 's/{/"{/g;' \
    -e 's/}/}"/g;' \
  | sublime_wants_containers_on_single_line \
  | perl -p \
      -e 's/'\''BraceWrapping'\''/"BraceWrapping"/g;' \
      -e 's/'\''ForEachMacros'\''/"ForEachMacros"/g;' \
  | grep -v "''" \
  #

  echo "}"
}

deploy_plugin() {
  case "$1" in
    emacs)
      abort "ERROR: emacs not yet supported"
      ;;
    vim)
      abort "ERROR: vim not yet supported"
      ;;
    sublime)
      cat_style_file | reformat_sublime > clang_format_custom.sublime-settings
      ;;
    *)
      cat <<_EOF_
ERROR: plugin takes an argument to specify the IDE.
Options are: 'emacs', 'vim', or 'sublime'
You provided: '$1'

_EOF_
      print_help_menu
      exit 1
      ;;
  esac
}

# Print pretty error message to stderr so it doesn't interfere with the list
# of files, in case someone wants to redirect it to a file.
print_error_header() {
  cat >&2 <<"_EOF_"
 _____________
< Style Error >
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

Please use spruce to reformat your code.
See https://gitlab.oblong.com/platform/docs/wikis/coding-style

Offending file(s):
_EOF_
}

# Run style check on given files without changing them
# Abort loudly on style error
# Exit silently on success
check_files() {
  failed=false
  for f
  do
    if ! is_formattable_file "$f"
    then
        echo "Skipping $f (filename doesn't look like c/c++/objc)"
        continue
    fi
    if $CLANG_FORMAT_PROGNAME -style="$(cat_style_string)" -output-replacements-xml < $f |
      grep "<replacement " > /dev/null
    then
      if ! $failed
      then
        failed=true
        print_error_header
      fi
      echo $f
    fi
  done
  if $failed
  then
    exit 1
  fi
}

case "$1" in
  style)
    cat_style_file
    ;;
  plugin)
    # Provide plugin support for given IDE
    if [ $# -ne 2 ] ; then
      cat <<_EOF_
ERROR: plugin takes an argument to specify the IDE.
Options are: 'emacs', 'vim', or 'sublime'

_EOF_
      IN_ERR=true
      print_help_menu
    fi
    deploy_plugin "$2"
    ;;
  all)
    # format all .C/.c/.h/.cpp files that are not in the IGNORE_PATHS
    # shellcheck disable=SC2046
    format_files $(find . -type f -iname '*.[ch]' -o -iname '*.cpp' | egrep -wv "$IGNORE_PATHS")
    ;;
  changes)
    format_changes
    ;;
  precommit)
    # Check all staged .C/.c/.h/.cpp files that are not in the IGNORE_PATHS
    # shellcheck disable=SC2046
    check_files $(git diff --name-only HEAD --diff-filter=AM | egrep -i '\.[ch]$|\.cpp$' | egrep -wv "$IGNORE_PATHS")
    ;;
  check)
    shift
    # Check given .C/.c/.h/.cpp files (default: all that are not in the IGNORE_PATHS)
    if test "$*" = ""
    then
        # shellcheck disable=SC2046
        check_files $(find . -type f -iname '*.[ch]' -o -iname '*.cpp' | sed 's,^\./,,' | egrep -wv "$IGNORE_PATHS")
    else
        check_files "$@"
    fi
    ;;
  freebase)
    shift
    # Fix a branch whose upstream has since been reformatted
    if [ $# -ne 3 ] ; then
      cat <<_EOF_
ERROR: freebase takes 3 args: sha1_before_reformat sha1_after_reformat upstream_branch
but you provided: $@

_EOF_
      IN_ERR=true
      print_help_menu
    fi
    reformat_branch "$1" "$2" "$3"
    ;;
  *)
    if ! test -f "$1"
    then
        echo "ERROR: $1 is not a file or command?"
        echo ""
        print_help_menu
        exit 1
    fi
    # shellcheck disable=SC2046,SC2012
    format_files $(ls -d "$@" | egrep -wv "$IGNORE_PATHS")
    ;;
esac
